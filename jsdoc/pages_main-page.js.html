<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Documentation Source: pages/main-page.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cerulean.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top navbar-inverse">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">Documentation</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="app.Alarm.html">app.Alarm</a></li><li><a href="app.CB.html">app.CB</a></li><li><a href="app.ChromeMsg.html">app.ChromeMsg</a></li><li><a href="app.Data.html">app.Data</a></li><li><a href="app.DB.html">app.DB</a></li><li><a href="app.Devices.html">app.Devices</a></li><li><a href="app.Fb.html">app.Fb</a></li><li><a href="app.GA.html">app.GA</a></li><li><a href="app.Gae.html">app.Gae</a></li><li><a href="app.Msg.html">app.Msg</a></li><li><a href="app.Notify.html">app.Notify</a></li><li><a href="app.Permissions.html">app.Permissions</a></li><li><a href="app.Reg.html">app.Reg</a></li><li><a href="app.SW.html">app.SW</a></li><li><a href="app.User.html">app.User</a></li><li><a href="app.Utils.html">app.Utils</a></li><li><a href="Background.html">Background</a></li><li><a href="Chrome.GA.html">Chrome.GA</a></li><li><a href="Chrome.Http.html">Chrome.Http</a></li><li><a href="Chrome.JSONUtils.html">Chrome.JSONUtils</a></li><li><a href="Chrome.Locale.html">Chrome.Locale</a></li><li><a href="Chrome.Log.html">Chrome.Log</a></li><li><a href="Chrome.Msg.html">Chrome.Msg</a></li><li><a href="Chrome.Storage.html">Chrome.Storage</a></li><li><a href="Chrome.Utils.html">Chrome.Utils</a></li><li><a href="ContentScript.html">ContentScript</a></li><li><a href="DevicesPage.html">DevicesPage</a></li><li><a href="ErrorPage.html">ErrorPage</a></li><li><a href="HelpPage.html">HelpPage</a></li><li><a href="LabelsPage.html">LabelsPage</a></li><li><a href="Main.html">Main</a></li><li><a href="MainPage.html">MainPage</a></li><li><a href="ReceiveMsg.html">ReceiveMsg</a></li><li><a href="ServiceWorker.html">ServiceWorker</a></li><li><a href="SettingBackground.html">SettingBackground</a></li><li><a href="SettingDropdown.html">SettingDropdown</a></li><li><a href="SettingLink.html">SettingLink</a></li><li><a href="SettingSlider.html">SettingSlider</a></li><li><a href="SettingsPage.html">SettingsPage</a></li><li><a href="SettingText.html">SettingText</a></li><li><a href="SettingTime.html">SettingTime</a></li><li><a href="SettingToggle.html">SettingToggle</a></li><li><a href="SignInPage.html">SignInPage</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="Chrome.Time.html">Chrome.Time</a></li><li><a href="ClipItem.html">ClipItem</a></li><li><a href="Device.html">Device</a></li><li><a href="ExceptionHandler.html">ExceptionHandler</a></li><li><a href="Label.html">Label</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: pages/main-page.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">(function() {
    'use strict';

    new ExceptionHandler();

    const _ERR_LOAD = 'Failed to load Clips';

    let self;

    // noinspection JSUnusedLocalSymbols
    /**
     * Polymer element to display and manage {@link ClipItem} objects
     * @namespace MainPage
     */
    Polymer({
      is: 'main-page',

      properties: {
        /**
         * {@link ClipItem} currently being viewed
         * @memberOf MainPage
         */
        currentClip: {
          type: Object,
          value: null,
          notify: true,
          observer: '_currentClipChanged',
        },

        /**
         * Array of {@link ClipItem} objects filtered by {@link labelFilter}
         * @memberOf MainPage
         */
        clips: {
          type: Array,
          value: [],
          notify: true,
        },

        /**
         * Array of selected {@link ClipItem} objects
         * @memberOf MainPage
         */
        selClips: {
          type: Array,
          value: [],
          notify: true,
        },

        /**
         * True if we have selected items
         * @memberOf MainPage
         */
        hasSelections: {
          type: Boolean,
          computed: '_computeHasSelections(selClips.splices)',
        },

        /**
         * True if we can send the clipboard contents
         * @memberOf MainPage
         */
        canSend: {
          type: Boolean,
          value: false,
          notify: true,
        },

        /**
         * Array of {@link ClipItem} objects that have been recently deleted
         * @memberOf MainPage
         */
        undoClips: {
          type: Array,
          value: [],
          notify: true,
        },

        /**
         * Message of undo toast
         * @memberOf MainPage
         */
        undoText: {
          type: String,
          value: '',
          notify: true,
        },

        /**
         * True if we are only showing favorite items
         * @memberOf MainPage
         */
        isFavFilter: {
          type: Boolean,
          value: false,
          notify: true,
        },

        /**
         * True if we are showing favorite items at top of list
         * @memberOf MainPage
         */
        isPinFavs: {
          type: Boolean,
          value: false,
          notify: true,
          observer: '_pinFavsChanged',
        },

        /**
         * {@link Label} name for filtering our items
         * @memberOf MainPage
         */
        labelFilter: {
          type: String,
          value: null,
          notify: true,
          observer: '_labelFilterChanged',
        },

        /**
         * Array of all {@link Label} names
         * @memberOf MainPage
         */
        labels: {
          type: Array,
          value: [],
          notify: true,
        },

        /**
         * Array of all {@link Label} names for the current clip
         * @memberOf MainPage
         */
        currentLabels: {
          type: Array,
          value: [],
          notify: true,
        },

        /**
         * Array of all selected {@link Label} names in the dialog
         * @memberOf MainPage
         */
        selDialogLabels: {
          type: Array,
          value: [],
          notify: true,
        },

        /**
         * True if label changes in dialog should apply to all selectedClips
         * @memberOf MainPage
         */
        isMultiLabelsEdit: {
          type: Boolean,
          value: false,
          notify: true,
        },

        /**
         * True if we are performing an operation on multiple clips
         * @memberOf MainPage
         */
        isBulkOp: {
          type: Boolean,
          value: false,
          notify: true,
          observer: '_bulkOpChanged',
        },
      },

      observers: [
        '_selDialogLabelsAddedOrRemoved(selDialogLabels.splices)',
      ],

      /**
       * Element is ready
       * @memberOf MainPage
       */
      ready: function() {
        self = this;
        this.addEventListener('focus', this._onFocused.bind(this), true);
        this.set('canSend', app.Utils.canSend());
        this._loadClipItems(true).then(() => {
          Chrome.Msg.listen(this._onChromeMessage);

          // listen for copy and cut events on document
          document.addEventListener('cut', this._onCopy, true);
          document.addEventListener('copy', this._onCopy, true);

          return Promise.resolve();
        }).catch((err) => {
          Chrome.Log.error(err.message, 'MainPage.ready', _ERR_LOAD);
        });
      },

      /**
       * We have animated in and are now the current page
       * @memberOf MainPage
       */
      onCurrentPage: function() {
        this.set('isBulkOp', false);
        this.set('canSend', app.Utils.canSend());
        this._selectFirst(true);
        this.updateDates();
      },

      /**
       * We are not going to be current anymore
       * @memberOf MainPage
       */
      onLeavePage: function() {
        this.set('isBulkOp', false);
        this._closeUndoToast();
        this._deselectAll();
      },

      /**
       * Update the relative dates
       * @memberOf MainPage
       */
      updateDates: function() {
        if (this.isBulkOp || (this.clips === undefined)) {
          return;
        }
        for (let i = 0; i &lt; this.clips.length; i++) {
          const date = this.clips[i].date;
          this.set(`clips.${i}.date`, date - 1);
          this.set(`clips.${i}.date`, date);
        }
      },

      /**
       * Set {@link Label} name for filtering
       * @param {?string} labelName
       * @memberOf MainPage
       */
      setLabelFilter: function(labelName) {
        this.set('labelFilter', labelName);
      },

      // noinspection JSUnusedLocalSymbols
      /**
       * Event: Fired when a message is sent from either an extension process&lt;br>
       * (by runtime.sendMessage) or a content script (by tabs.sendMessage).
       * @see https://developer.chrome.com/extensions/runtime#event-onMessage
       * @param {Chrome.Msg.Message} request - details for the
       * @param {Object} sender - MessageSender object
       * @param {function} response - function to call once after processing
       * @returns {boolean} true if asynchronous
       * @private
       * @memberOf MainPage
       */
      _onChromeMessage: function(request, sender, response) {
        let ret = false;
        if (request.message === app.ChromeMsg.CLIP_ITEM_CREATED.message) {
          ret = true; // async
          self._addClipItem(request.item);
        } else if (request.message === app.ChromeMsg.CLIP_ITEM_UPDATED.message) {
          const item = request.item;
          self._updateClipItem(item.text, item.mods);
        } else if (request.message === app.ChromeMsg.CLIP_ITEM_DELETED.message) {
          self._deleteClipItem(request.item);
        }
        return ret;
      },

      /**
       * Event: Select labels menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onSelectLabelsTapped: function() {
        Chrome.GA.event(Chrome.GA.EVENT.ICON, 'selectLabels');
        this._showLabelsSelectDialog(true);
      },

      /**
       * Event: Labels section of ClipViewer tapped
       * @private
       * @memberOf MainPage
       */
      _onLabelsTapped: function() {
        Chrome.GA.event(app.GA.EVENT.CLICK, 'showLabelList');
        this._showLabelsSelectDialog(false);
      },

      /**
       * Event: Undo Toast close button tapped
       * @private
       * @memberOf MainPage
       */
      _onCloseToastTapped: function() {
        Chrome.GA.event(app.GA.EVENT.IMAGE_BUTTON, 'closeUndoToast');
        this._closeUndoToast();
      },

      /**
       * Event: Undo Toast button tapped&lt;br />
       * Restore the deleted Items
       * @private
       * @memberOf MainPage
       */
      _onUndoDeleteTapped: function() {
        Chrome.GA.event(Chrome.GA.EVENT.BUTTON, 'UNDO');
        this.set('isBulkOp', true);
        app.ClipItem.bulkPut(this.undoClips).then(() => {
          this.set('isBulkOp', false);
          // reset selections
          const list = this.$.ironList;
          this.undoClips.forEach((clipItem) => {
            // need to use new item reference - hashing issue in iron-list?
            const newClipItem = this._getClip(clipItem.text);
            if (newClipItem) {
              list.selectItem(newClipItem);
            }
          });
          this._setCurrentClip();
          if (this.selClips &amp;&amp; this.selClips.length) {
            list.scrollToItem(this.selClips[0]);
          }
          this._closeUndoToast();
          return Promise.resolve();
        }).catch((err) => {
          Chrome.Log.error(err.message, 'MainPage._onUndoDeleteTapped',
              'Failed to undo delete.');
          this.set('isBulkOp', false);
          this._closeUndoToast();
        });
      },

      /**
       * Event: Select all menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onSelectAllTapped: function() {
        Chrome.GA.event(Chrome.GA.EVENT.ICON, 'selectAllClipItems');
        this._deselectAll();
        this._selectAll();
      },

      /**
       * Event: Deselect all menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onDeselectAllTapped: function() {
        Chrome.GA.event(Chrome.GA.EVENT.ICON, 'deselectAllClipItems');
        this._deselectAll();
      },

      /**
       * Event: Delete menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onDeleteSelectedTapped: function() {
        Chrome.GA.event(Chrome.GA.EVENT.ICON, 'deleteSelectedClipItems');

        // save items for undo
        const keys = [];
        this.splice('undoClips', 0, this.undoClips.length);
        this.selClips.forEach((clipItem) => {
          keys.push(clipItem._id);
          this.push('undoClips', clipItem);
        });

        if (keys.length) {
          // skip updates until bulk operation is complete
          this.set('isBulkOp', true);
          this._deselectAll();
          app.ClipItem.remove(keys).then(() => {
            this.set('isBulkOp', false);
            const len = this.undoClips.length;
            let toastText =
                (len === 1) ? 'Deleted 1 item.' : `Deleted ${len} items.`;
            this.set('undoText', toastText);
            this.$.undoToast.show();
            return Promise.resolve();
          }).catch((err) => {
            this.set('isBulkOp', false);
            Chrome.Log.error(err.message, 'MainPage._onDeleteSelectedRows',
                'Failed to delete clips.');
          });
        }
      },

      /**
       * Event: Send clipboard contents icon tapped
       * @private
       * @memberOf MainPage
       */
      _onSendTapped: function() {
        Chrome.GA.event(Chrome.GA.EVENT.ICON, 'sendClipboardContents');
        Chrome.Msg.send(app.ChromeMsg.COPIED_TO_CLIPBOARD).catch(() => {});
      },

      /**
       * Event: Pin menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onPinTapped: function() {
        this.set('isPinFavs', !this.isPinFavs);
        Chrome.GA.event(Chrome.GA.EVENT.ICON, `pinFavorites: ${this.isPinFavs}`);
      },

      /**
       * Event: Favorite filter menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onFavFilterTapped: function() {
        this.set('isFavFilter', !this.isFavFilter);
        Chrome.GA.event(Chrome.GA.EVENT.ICON,
            `filterByFavorites: ${this.isFavFilter}`);

        this._loadClipItems(true).catch((err) => {
          Chrome.Log.error(err.message, 'MainPage._onFavFilterTapped', _ERR_LOAD);
        });
      },

      /**
       * Event: iron-list got focus
       * @param {Event} event
       * @param {ClipItem} event.model.clip
       * @private
       * @memberOf MainPage
       */
      _onFocused: function(event) {
        // !Important prevent iron-list from handling
        event.stopPropagation();
      },

      /**
       * Event: Tap on clip row - handle selections like a tree select
       * @param {Event} event
       * @param {ClipItem} event.model.clip
       * @private
       * @memberOf MainPage
       */
      _onClipRowTapped: function(event) {
        const isShift = event.detail.sourceEvent.shiftKey;
        const isCtrl = event.detail.sourceEvent.ctrlKey;
        const endPos = event.model.index;
        const curClipItem = this.clips[endPos];
        let selected = event.model.selected;

        Chrome.GA.event(app.GA.EVENT.CLICK, 'clipItemRow');

        if (isShift) {
          // select range of rows
          let startPos = -1;

          // override shitty iron-list scrolling
          const list = this.$.ironList;
          const firstIndex = list.firstVisibleIndex;
          list.scrollToIndex(0);

          if (selected) {
            // deselect any contiguous selections after 
            for (let i = endPos + 1; i &lt; this.clips.length; i++) {
              const clipItem = this.clips[i];
              if (this._isSelected(clipItem)) {
                list.deselectItem(clipItem);
              } else {
                break;
              }
            }
            list.scrollToIndex(firstIndex);
            this._setCurrentClip();
            return;
          } else if (!this.hasSelections) {
            // select from first to current
            startPos = 0;
          } else {
            for (let i = endPos - 1; i >= 0; i--) {
              // select from after newer selection to current
              const clipItem = this.clips[i];
              if (this._isSelected(clipItem)) {
                startPos = i;
                break;
              }
            }
            if (startPos === -1) {
              // try the other direction
              for (let i = endPos + 1; i &lt; this.clips.length; i++) {
                // select from before older selection to current
                const clipItem = this.clips[i];
                if (this._isSelected(clipItem)) {
                  startPos = i;
                  break;
                }
              }
            }
          }
          if (startPos !== -1) {
            // found range, select it
            const items = [];
            if (startPos &lt; endPos) {
              for (let i = startPos + 1; i &lt;= endPos; i++) {
                items.push(this.clips[i]);
              }
            } else if (startPos > endPos) {
              for (let i = startPos - 1; i >= endPos; i--) {
                items.push(this.clips[i]);
              }
            }
            this.push('selClips', ...items);
          }
          list.scrollToIndex(firstIndex);
          this._setCurrentClip();
        } else if (isCtrl) {
          // toggle selection
          if (selected) {
            this._deselect(curClipItem);
          } else {
            this._select(curClipItem);
          }
        } else {
          // single select with toggle
          const len = this.selClips.length;
          this._deselectAll();
          if (!selected || (len > 1)) {
            // item not selected or multiple selections before tap
            this._select(curClipItem);
          }
        }
      },

      /**
       * Event: Copy list row to clipboard
       * @param {Event} event
       * @param {ClipItem} event.model.clip
       * @private
       * @memberOf MainPage
       */
      _onRowCopyTapped: function(event) {
        Chrome.GA.event(app.GA.EVENT.IMAGE_BUTTON, 'copyClipItem');
        const clipItem = event.model.clip;
        clipItem.date = Date.now();
        clipItem.remote = false;
        clipItem.save().then(() => {
          // send message to copy to clipboard
          const msg =
              Chrome.JSONUtils.shallowCopy(app.ChromeMsg.COPY_TO_CLIPBOARD);
          msg.item = clipItem;
          // eslint-disable-next-line promise/no-nesting
          Chrome.Msg.send(msg).catch(() => {});
          return Promise.resolve();
        }).catch((err) => {
          Chrome.Log.error(err.message, 'MainPage._onRowCopyTapped',
              'Failed to copy item to clipboard.');
        });

        // prevent row selection
        event.stopPropagation();
      },

      /**
       * Event: Toggle favorite state of row
       * @param {Event} event
       * @param {ClipItem} event.model.clip
       * @private
       * @memberOf MainPage
       */
      _onRowFavTapped: function(event) {
        Chrome.GA.event(app.GA.EVENT.IMAGE_BUTTON, 'toggleFavorite');
        const clipItem = event.model.clip;
        if (clipItem) {
          clipItem.update({fav: !clipItem.fav}).catch((err) => {
            Chrome.Log.error(err.message, 'MainPage._onRowFavTapped');
          });
        }

        // prevent row selection
        event.stopPropagation();
      },

      /**
       * Event: Label icon of clip row tapped
       * @param {Event} event
       * @param {{}} event.model
       * @private
       * @memberOf MainPage
       */
      _onRowLabelTapped: function(event) {
        Chrome.GA.event(app.GA.EVENT.IMAGE_BUTTON, 'showLabelList');
        const clipItem = event.model.clip;
        this._deselectAll();
        this._select(clipItem);

        // prevent row deselection
        event.stopPropagation();

        this._showLabelsSelectDialog(false);
      },

      /**
       * Event: Text was copied to clipboard
       * @private
       * @memberOf MainPage
       */
      _onCopy: function() {
        Chrome.Msg.send(app.ChromeMsg.COPIED_TO_CLIPBOARD).catch(() => {});
      },

      /**
       * Event: Initialize pinFavs if it is not in localStorage
       * @private
       * @memberOf MainPage
       */
      _initPinFavs: function() {
        this.set('isPinFavs', 'false');
      },

      /**
       * Observer: The current clip changed
       * @private
       * @memberOf MainPage
       */
      _currentClipChanged: function() {
        this.updateDates();

        // clear text
        const el = this.$.clipViewerText;
        while (el.firstChild) {
          // delete all children previous linkify created
          el.removeChild(el.firstChild);
        }

        // set the current labels

        // not guaranteed to be initialized yet
        if (this.currentLabels === undefined) {
          this.currentLabels = [];
        }
        this.$.clipViewerLabels.style.display = 'none';
        this.splice('currentLabels', 0, this.currentLabels.length);

        const clipItem = this.currentClip;
        if (!clipItem) {
          return;
        }

        const names = clipItem.getLabelNames();
        names.forEach((name) => {
          if (!this.currentLabels.includes(name)) {
            this.push('currentLabels', name);
          }
        });

        if (this.currentLabels &amp;&amp; this.currentLabels.length) {
          this.$.clipViewerLabels.style.display = 'block';
        }

        // set text
        el.textContent = clipItem.text;
        // linkify it - creates element children
        linkifyElement(el);
      },

      /**
       * Observer: The label filter changed
       * @param {string} newValue
       * @param {string|undefined} oldValue
       * @private
       * @memberOf MainPage
       */
      _labelFilterChanged: function(newValue, oldValue) {
        if (typeof(oldValue) !== 'undefined') {
          this._deselectAll();
          this._loadClipItems().catch((err) => {
            Chrome.Log.error(err.message, 'MainPage.setLabelFilter', _ERR_LOAD);
          });
        }
      },

      /**
       * Observer: The pinFavs setting changed
       * @param {boolean} newValue
       * @param {boolean|undefined} oldValue
       * @private
       * @memberOf MainPage
       */
      _pinFavsChanged: function(newValue, oldValue) {
        if (typeof(oldValue) !== 'undefined') {
          this._deselectAll();
          this._sortClipItems();
          this._selectFirst();
        }
      },

      /**
       * Observer: The bulkOp setting changed
       * @param {boolean} newValue
       * @param {boolean|undefined} oldValue
       * @private
       * @memberOf MainPage
       */
      _bulkOpChanged: function(newValue, oldValue) {
        if (typeof(oldValue) !== 'undefined') {
          if (!newValue &amp;&amp; oldValue) {
            // toggling from true to false
            if (this.clips &amp;&amp; this.clips.length) {
              this._sortClipItems();
            } else {
              // no clips
              this.set('clips', []);
              this._updateSelections([], 0);
            }
          }
        }
      },

      /**
       * Observer: selDialogLabels Array mutations
       * @param {{}} changeRecord
       * @private
       * @memberOf MainPage
       */
      _selDialogLabelsAddedOrRemoved: function(changeRecord) {
        if (changeRecord) {
          this.set('isBulkOp', true);
          const promises = [];
          if (this.isMultiLabelsEdit) {
            // track each added and removed label change and
            // apply to each selected clip
            const addedNames = [];
            const removedNames = [];
            const splices = changeRecord.indexSplices;
            splices.forEach((splice) => {
              for (let i = 0; i &lt; splice.addedCount; i++) {
                let index = splice.index + i;
                addedNames.push(splice.object[index]);
              }
              splice.removed.forEach((name) => {
                removedNames.push(name);
              });
            });
            this.selClips.forEach((clipItem) => {
              const names = clipItem.getLabelNames();
              
              addedNames.forEach((addedName) => {
                if (!clipItem.hasLabel(addedName)) {
                  names.push(addedName);
                }
              });
              
              removedNames.forEach((removedName) => {
                if (clipItem.hasLabel(removedName)) {
                  const idx = names.indexOf(removedName);
                  names.splice(idx, 1);
                }
              });
              
              promises.push(clipItem.setLabels(names));
            });
          } else {
            // apply to current clip
            const clipItem = this.currentClip;
            promises.push(clipItem.setLabels(this.selDialogLabels));
          }

          Promise.all(promises).then(() => {
            this.set('isBulkOp', false);
            if (this.labelFilter &amp;&amp;
                !this.selDialogLabels.includes(this.labelFilter)) {
              // deleted current label from item(s) 
              this.$.labelsDialog.close();
              return this._loadClipItems();
            } else {
              this._setCurrentClip();
              return Promise.resolve();
            }
          }).catch((err) => {
            this.set('isBulkOp', false);
            Chrome.Log.error(err.errorMessage,
                'MainPage._onSelectedLabelsChanged', 'Failed to set label.');
          });
        }
      },

      /**
       * Computed Property: Do we have selected items
       * @returns {boolean}
       * @private
       * @memberOf MainPage
       */
      _computeHasSelections: function() {
        return !!(this.selClips &amp;&amp; this.selClips.length);
      },

      /**
       * Computed Binding
       * @param {ClipItem} clipItem
       * @param {string} labelName
       * @returns {string} Page title
       * @private
       * @memberOf MainPage
       */
      _computeTitle: function(clipItem, labelName) {
        let title = 'Clips';
        if (!Chrome.Utils.isWhiteSpace(labelName)) {
          title = `${labelName}`;
        }
        if (clipItem) {
          if (clipItem.remote) {
            title += `: Remote clip - ${clipItem.device}`;
          } else {
            title += ': Local clip';
          }
        }
        return title;
      },

      /**
       * Computed Binding: Title of Labels Dialog
       * @param {boolean} multi - true if dialog applies to all selectedClips
       * @returns {string} Dialog title
       * @private
       * @memberOf MainPage
       */
      _computeLabelsDialogTitle: function(multi) {
        if (multi &amp;&amp; this.selClips &amp;&amp; (this.selClips.length > 1)) {
          return 'Change labels for selected clips';
        } else {
          return 'Set labels for the current clip';
        }
      },

      /**
       * Computed Binding
       * @param {boolean} isTrue - true if we should pin favs to top
       * @returns {string} icon style
       * @private
       * @memberOf MainPage
       */
      _computePinIcon: function(isTrue) {
        return isTrue ? 'myicons:pin' : 'myicons:pin-off';
      },

      /**
       * Computed Binding
       * @param {boolean} isTrue - true if fav
       * @returns {string} icon style
       * @private
       * @memberOf MainPage
       */
      _computeFavIcon: function(isTrue) {
        return isTrue ? 'myicons:favorite' : 'myicons:favorite-border';
      },

      /**
       * Computed Binding
       * @param {boolean} isTrue - true if pinning favorites
       * @returns {string} tooltip text of what toggling would be
       * @private
       * @memberOf MainPage
       */
      _computePinToolTip: function(isTrue) {
        return isTrue ? 'Unpin favorites' : 'Pin favorites to top';
      },

      /**
       * Computed Binding
       * @param {boolean} isTrue - true if fav
       * @returns {string} Favorite icon color
       * @private
       * @memberOf MainPage
       */
      _computeFavColor: function(isTrue) {
        return isTrue ? 'rgba(255, 0, 0, .8)' : 'var(--primary-text-color)';
      },

      /**
       * Computed Binding
       * @param {boolean} isTrue - true if fav
       * @returns {string} fav filter menu icon color
       * @private
       * @memberOf MainPage
       */
      _computeFavMenuColor: function(isTrue) {
        return isTrue ? 'rgba(255, 0, 0, .8)' : 'var(--menu-icon-color)';
      },

      /**
       * Computed Binding
       * @param {boolean} isFilter - true if filtering by fav
       * @returns {string} tooltip text of what toggling would be
       * @private
       * @memberOf MainPage
       */
      _computeFavToolTip: function(isFilter) {
        return isFilter ? 'Show all' : 'Show favorites only';
      },

      /**
       * Computed Binding
       * @param {int} date - from epoch in millis
       * @returns {string} Date as relative from now
       * @private
       * @memberOf MainPage
       */
      _computeDate: function(date) {
        return app.Utils.getRelativeTime(date);
      },

      /**
       * Computed Binding: Clip item classList
       * @param {boolean} selected - is clip selected
       * @returns {string} Clip item classList
       * @private
       * @memberOf MainPage
       */
      _computeClipClass: function(selected) {
        let classList = 'clip-item';
        if (selected) {
          classList += ' selected';
        }
        return classList;
      },

      /**
       * Load the {@link ClipItem} objects
       * @param {boolean} [selectFirst=true] - if true select first item
       * @returns {Promise&lt;void>}
       * @private
       * @memberOf MainPage
       */
      _loadClipItems: function(selectFirst = true) {
        this._closeUndoToast();
        this._deleteAllClipItems();
        this._deselectAll();
        return app.ClipItem.loadAll(this.labelFilter).then((clipItems) => {
          // populate list
          if (this.isFavFilter) {
            // favorites only
            const favClipItems = clipItems.filter((clipItem) => {
              return clipItem.fav;
            });
            this.push('clips', ...favClipItems);
          } else {
            this.push('clips', ...clipItems);
          }
          this._sortClipItems();
          if (selectFirst) {
            this._selectFirst();
          }
          // HACK not sure why this is needed but it loses selection
          // on first opening of UI otherwise
          this._deselectAll();
          if (selectFirst) {
            this._selectFirst();
          }
          return Promise.resolve();
        });
      },

      /**
       * Sort the {@link ClipItem} list
       * @private
       * @memberOf MainPage
       */
      _sortClipItems: function() {
        if (this.isBulkOp) {
          return;
        }

        /**
         * Sort by date
         * @param {ClipItem} a
         * @param {ClipItem} b
         * @returns {number}
         */
        function byDate(a, b) {
          return b.date - a.date;
        }

        // override shitty iron-list scrolling
        const list = this.$.ironList;
        const firstIndex = list.firstVisibleIndex;
        list.scrollToIndex(0);

        // copy of current selections
        const selClips = this.selClips.slice();

        if (this.isPinFavs) {
          // sort favs and non-favs separately and keep favs on top
          const favClips = this.clips.filter((clip) => {
            return clip.fav;
          });
          favClips.sort(byDate);
          const nonFavClips = this.clips.filter((clip) => {
            return !clip.fav;
          });
          nonFavClips.sort(byDate);
          this._deleteAllClipItems();
          // populate list
          this.push('clips', ...favClips);
          this.push('clips', ...nonFavClips);
        } else {
          // sort by date
          const clips = this.clips.slice();
          clips.sort(byDate);
          this._deleteAllClipItems();
          this.push('clips', ...clips);
        }
        this._updateSelections(selClips, firstIndex);
      },

      /**
       * Add a {@link ClipItem} to the list
       * @param {string} text - ClipItem text
       * @private
       * @memberOf MainPage
       */
      _addClipItem: function(text) {
        app.ClipItem.getNew(text).then((clipItem) => {
          if (this._getClipPos(clipItem.text) === -1) {
            if (!this.labelFilter || clipItem.hasLabel(this.labelFilter)) {
              // add to list if not filtering or has our labelFilter
              if (this.isBulkOp) {
                this.clips.unshift(clipItem);
              } else {
                this.unshift('clips', clipItem);
                this._sortClipItems();
              }
            }
          }
          return Promise.resolve();
        }).catch((err) => {
          Chrome.Log.error(err.message, 'MainPage._addClipItem',
              'Failed to add clip item');
        });
      },

      /**
       * Update a {@link ClipItem} in the list
       * @param {string} text - ClipItem text
       * @param {Object} mods - key/value pairs of changes
       * @private
       * @memberOf MainPage
       */
      _updateClipItem: function(text, mods) {
        const pos = this._getClipPos(text);
        if (pos !== -1) {
          const oldClipItem = this.clips[pos];
          let needsSort = false;
          const str = `clips.${pos}.`;
          for (const key of Object.keys(mods)) {
            // check if props that affect sort changed
            if (key === 'fav') {
              if (this.isPinFavs &amp;&amp; (mods[key] !== oldClipItem.fav)) {
                needsSort = true;
              }
            }
            this.set(`${str}${key}`, mods[key]);
          }

          if (this.currentClip &amp;&amp;
              (oldClipItem.text === this.currentClip.text) &amp;&amp;
              mods.hasOwnProperty('labels')) {
            // update clip if labels changed
            this._setCurrentClip();
          }

          if (!needsSort &amp;&amp; mods.hasOwnProperty('date')) {
            needsSort = true;
          }

          if (needsSort) {
            this._sortClipItems();
          } else {
            this.updateDates();
          }
        }
      },

      /**
       * Delete a {@link ClipItem} from the list
       * @param {string} text - ClipItem text
       * @private
       * @memberOf MainPage
       */
      _deleteClipItem: function(text) {
        const pos = this._getClipPos(text);
        if (pos !== -1) {
          if (this.isBulkOp) {
            this.clips.splice(pos, 1);
          } else {
            this.splice('clips', pos, 1);
            this.updateDates();
          }
        }
      },

      /**
       * Delete all {@link ClipItem} objects
       * @private
       * @memberOf MainPage
       */
      _deleteAllClipItems: function() {
        if (this.clips &amp;&amp; this.clips.length) {
          this.splice('clips', 0, this.clips.length);
        }
      },

      /**
       * Get clip from text
       * @param {string} clipText - text to find
       * @returns {?ClipItem} null if not found
       * @private
       * @memberOf MainPage
       */
      _getClip: function(clipText) {
        return this.clips.find((clipItem) => {
          return (clipText === clipItem.text);
        });
      },

      /**
       * Get position of row with given text
       * @param {string} clipText - text to find
       * @returns {int} position in array, -1 if not found
       * @private
       * @memberOf MainPage
       */
      _getClipPos: function(clipText) {
        return this.clips.findIndex((clipItem) => {
          return (clipText === clipItem.text);
        });
      },

      /**
       * Update the selected items
       * @param {ClipItem[]} selClips - ClipItems to select
       * @param {int} [scrollIndex = 0]
       * @private
       * @memberOf MainPage
       */
      _updateSelections: function(selClips, scrollIndex = 0) {
        const list = this.$.ironList;
        list.clearSelection();
        this.push('selClips', ...selClips);
        list.scrollToIndex(scrollIndex);
        this._setCurrentClip();
      },

      /**
       * Is a {@link ClipItem} selected
       * @param {ClipItem} clipItem
       * @returns {boolean}
       * @private
       * @memberOf MainPage
       */
      _isSelected: function(clipItem) {
        const idx = this.selClips.findIndex((clip) => {
          return (clip.text === clipItem.text);
        });
        return (idx !== -1);
      },

      /**
       * Select {@link ClipItem} if not already
       * @param {ClipItem} clipItem
       * @returns {boolean} true if selected
       * @private
       * @memberOf MainPage
       */
      _select: function(clipItem) {
        let ret = false;
        if (clipItem &amp;&amp; !this._isSelected(clipItem)) {
          this.$.ironList.selectItem(clipItem);
          if (!this.isBulkOp) {
            this._setCurrentClip();
          }
          ret = true;
        }
        return ret;
      },

      /**
       * Deselect {@link ClipItem} if not already
       * @param {ClipItem} clipItem
       * @returns {boolean} true if deselected
       * @private
       * @memberOf MainPage
       */
      _deselect: function(clipItem) {
        let ret = false;
        if (clipItem &amp;&amp; this._isSelected(clipItem)) {
          this.$.ironList.deselectItem(clipItem);
          if (!this.isBulkOp) {
            this._setCurrentClip();
          }
          ret = true;
        }
        return ret;
      },

      /**
       * Select all {@link ClipItem}
       * @private
       * @memberOf MainPage
       */
      _selectAll: function() {
        if (this.clips &amp;&amp; this.clips.length) {
          const list = this.$.ironList;
          list.clearSelection();
          this.push('selClips', ...this.clips);
          list.scrollToIndex(0);
          this._setCurrentClip();
        }
      },

      /**
       * Deselect all {@link ClipItem}
       * @private
       * @memberOf MainPage
       */
      _deselectAll: function() {
        if (this.selClips &amp;&amp; this.selClips.length) {
          this.$.ironList.clearSelection();
        }
        this._setCurrentClip();
      },

      /**
       * Select first item in list, if it is not already
       * @param {boolean} [ifNoSelections=false] - if true,
       * only do if no selections
       * @returns {boolean} true if selected
       * @private
       * @memberOf MainPage
       */
      _selectFirst: function(ifNoSelections = false) {
        if (!this.clips || !this.clips.length ||
            (ifNoSelections &amp;&amp; this.selClips.length)) {
          return false;
        }
        const clipItem = this.clips[0];
        const ret = this._select(clipItem);
        this.$.ironList.scrollToIndex(0);
        return ret;
      },

      /**
       * Set clip viewer contents based on last selected
       * @private
       * @memberOf MainPage
       */
      _setCurrentClip: function() {
        let currentItem = null;
        if (this.selClips &amp;&amp; this.selClips.length) {
          currentItem = this.selClips[this.selClips.length - 1];
        }
        // override dirty checking
        this.set('currentClip', null);
        if (currentItem) {
          this.set('currentClip', currentItem);
        }
      },

      /**
       * Get the labels shared by all selected {@link ClipItem} objects
       * @returns {string[]} Array of all shared Label names
       * @private
       * @memberOf MainPage
       */
      _getCommonLabelsForSelected: function() {
        const labels = [];
        this.labels.forEach((labelName) => {
          let hasLabel = true;
          for (let i = 0; i &lt; this.selClips.length; i++) {
            const clipItem = this.selClips[i];
            if (!clipItem.hasLabel(labelName)) {
              hasLabel = false;
              break;
            }
          }
          if (hasLabel) {
            labels.push(labelName);
          }
        });
        return labels;
      },

      /**
       * Show Labels select dialog
       * @param {boolean} multi - if true apply changes to all selectItems
       * @private
       * @memberOf MainPage
       */
      _showLabelsSelectDialog: function(multi) {
        this.set('isMultiLabelsEdit', multi);
        app.Label.loadAll().then((labels) => {
          this.splice('labels', 0, this.labels.length);
          labels.forEach((label) => {
            this.push('labels', label.name);
          });
          return Promise.resolve();
        }).then(() => {
          if (multi &amp;&amp; (this.selClips.length > 1)) {
            // for multi mode, will apply to all selectedClips
            const labels = this._getCommonLabelsForSelected();
            this.set('selDialogLabels', labels);
          } else {
            this._setSelectedLabels(this.currentClip);
          }
          return Promise.resolve();
        }).then(() => {
          this.$.labelsDialog.open();
          return Promise.resolve();
        }).catch((err) => {
          Chrome.Log.error(err.message, 'MainPage._showLabelsSelectDialog',
              'Failed to load labels');
        });
      },

      /**
       * Set the selected labels based on a {@link ClipItem}
       * @param {ClipItem} clipItem
       * @private
       * @memberOf MainPage
       */
      _setSelectedLabels: function(clipItem) {
        if (this.selDialogLabels &amp;&amp; this.selDialogLabels.length) {
          this.splice('selDialogLabels', 0, this.selDialogLabels.length);
        }
        if (clipItem) {
          const names = clipItem.getLabelNames();
          this.push('selDialogLabels', ...names);
        }
      },

      /**
       * Close the Undo Toast
       * @private
       * @memberOf MainPage
       */
      _closeUndoToast: function() {
        if (this.undoClips &amp;&amp; this.undoClips.length) {
          this.splice('undoClips', 0, this.undoClips.length);
        }
        this.$.undoToast.close();
      },
    });

    /**
     * Document and resources loaded
     * @private
     * @memberOf MainPage
     */
    function _onLoad() {
      const db = app.DB.get();
      if (!db) {
        Chrome.Log.error('Failed to get database reference', 'MainPage._onLoad',
            'Database not found');
        return;
      }

      db.clipItems.hook('creating', function(primKey, obj) {
        // eslint-disable-next-line no-invalid-this
        this.onsuccess = function() {
          self._addClipItem(obj.text);
        };
      });

      db.clipItems.hook('updating', function(mods, primKey, obj) {
        // eslint-disable-next-line no-invalid-this
        this.onsuccess = function() {
          self._updateClipItem(obj.text, mods);
        };
      });

      db.clipItems.hook('deleting', function(primKey, obj) {
        // eslint-disable-next-line no-invalid-this
        this.onsuccess = function() {
          self._deleteClipItem(obj.text);
        };
      });
    }

    // listen for document and resources loaded
    window.addEventListener('load', _onLoad);
  })();</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


	<span class="copyright">
	DocStrap Copyright Â© 2012-2015 The contributors to the JSDoc3 and DocStrap projects.
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a>
	
		on December 9th 2017, 8:22:46 am
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
