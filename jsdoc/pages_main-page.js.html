<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Documentation Source: pages/main-page.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cerulean.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top navbar-inverse">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">Documentation</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="app.Alarm.html">app.Alarm</a></li><li><a href="app.CB.html">app.CB</a></li><li><a href="app.ChromeMsg.html">app.ChromeMsg</a></li><li><a href="app.Data.html">app.Data</a></li><li><a href="app.DB.html">app.DB</a></li><li><a href="app.Devices.html">app.Devices</a></li><li><a href="app.Fb.html">app.Fb</a></li><li><a href="app.GA.html">app.GA</a></li><li><a href="app.Gae.html">app.Gae</a></li><li><a href="app.Msg.html">app.Msg</a></li><li><a href="app.Notify.html">app.Notify</a></li><li><a href="app.Permissions.html">app.Permissions</a></li><li><a href="app.Reg.html">app.Reg</a></li><li><a href="app.SW.html">app.SW</a></li><li><a href="app.User.html">app.User</a></li><li><a href="app.Utils.html">app.Utils</a></li><li><a href="Background.html">Background</a></li><li><a href="Chrome.Auth.html">Chrome.Auth</a></li><li><a href="Chrome.GA.html">Chrome.GA</a></li><li><a href="Chrome.Http.html">Chrome.Http</a></li><li><a href="Chrome.JSONUtils.html">Chrome.JSONUtils</a></li><li><a href="Chrome.Locale.html">Chrome.Locale</a></li><li><a href="Chrome.Log.html">Chrome.Log</a></li><li><a href="Chrome.Msg.html">Chrome.Msg</a></li><li><a href="Chrome.Storage.html">Chrome.Storage</a></li><li><a href="Chrome.Utils.html">Chrome.Utils</a></li><li><a href="ClipList.html">ClipList</a></li><li><a href="ClipRow.html">ClipRow</a></li><li><a href="ClipViewer.html">ClipViewer</a></li><li><a href="ContentScript.html">ContentScript</a></li><li><a href="DevicesPage.html">DevicesPage</a></li><li><a href="ErrorPage.html">ErrorPage</a></li><li><a href="HelpPage.html">HelpPage</a></li><li><a href="LabelsDialog.html">LabelsDialog</a></li><li><a href="LabelsPage.html">LabelsPage</a></li><li><a href="Main.html">Main</a></li><li><a href="MainPage.html">MainPage</a></li><li><a href="ReceiveMsg.html">ReceiveMsg</a></li><li><a href="ServiceWorker.html">ServiceWorker</a></li><li><a href="SettingBackground.html">SettingBackground</a></li><li><a href="SettingDropdown.html">SettingDropdown</a></li><li><a href="SettingLink.html">SettingLink</a></li><li><a href="SettingSlider.html">SettingSlider</a></li><li><a href="SettingsPage.html">SettingsPage</a></li><li><a href="SettingText.html">SettingText</a></li><li><a href="SettingTime.html">SettingTime</a></li><li><a href="SettingToggle.html">SettingToggle</a></li><li><a href="SignInPage.html">SignInPage</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="Chrome.Time.html">Chrome.Time</a></li><li><a href="ClipItem.html">ClipItem</a></li><li><a href="Device.html">Device</a></li><li><a href="ExceptionHandler.html">ExceptionHandler</a></li><li><a href="Label.html">Label</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="events.list.html" class="dropdown-toggle" data-toggle="dropdown">Events<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="ClipList.html#.event:row-label-tap">ClipList.event:row-label-tap</a></li><li><a href="ClipList.html#.event:selected-clip-change">ClipList.event:selected-clip-change</a></li><li><a href="ClipRow.html#.event:label-tap">ClipRow.event:label-tap</a></li><li><a href="ClipViewer.html#.event:clip-add">ClipViewer.event:clip-add</a></li><li><a href="ClipViewer.html#.event:labels-tapped">ClipViewer.event:labels-tapped</a></li><li><a href="ClipViewer.html#.event:text-changed">ClipViewer.event:text-changed</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="global.html#removeCachedToken">removeCachedToken</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: pages/main-page.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">(function() {
    'use strict';

    new ExceptionHandler();

    const _ERR_LOAD = 'Failed to load Clips';

    let self;

    // noinspection JSUnusedLocalSymbols
    /**
     * Polymer element to display and manage {@link ClipItem} objects
     * @namespace MainPage
     */
    Polymer({
      is: 'main-page',

      properties: {
        /**
         * {@link ClipItem} currently being viewed
         * @memberOf MainPage
         */
        currentClip: {
          type: Object,
          value: null,
          notify: true,
        },

        /**
         * Are we editing {@link currentClip}
         * @memberOf MainPage
         */
        isEditMode: {
          type: Boolean,
          value: false,
          notify: true,
        },

        /**
         * True if we are only showing favorite items
         * @type boolean
         * @memberOf MainPage
         */
        isFavFilter: {
          type: Boolean,
          value: false,
          notify: true,
        },

        /**
         * True if we are showing favorite items at top of list
         * @type boolean
         * @memberOf MainPage
         */
        isPinFavs: {
          type: Boolean,
          value: false,
          notify: true,
        },

        /**
         * {@link Label} name for filtering our items
         * @type string
         * @memberOf MainPage
         */
        labelFilter: {
          type: String,
          value: null,
          notify: true,
          observer: '_labelFilterChanged',
        },

        /**
         * True if we have selected items
         * @memberOf ClipList
         */
        hasSelections: {
          type: Boolean,
          notify: true,
        },

        /**
         * True if we can send the clipboard contents
         * @memberOf MainPage
         */
        canSend: {
          type: Boolean,
          value: false,
          notify: true,
        },

        /**
         * Array of {@link ClipItem} objects that have been recently deleted
         * @memberOf MainPage
         */
        undoClips: {
          type: Array,
          value: [],
          notify: true,
        },

        /**
         * Message of undo toast
         * @memberOf MainPage
         */
        undoText: {
          type: String,
          value: '',
          notify: true,
        },

        /**
         * Array of all selected {@link Label} names in the dialog
         * @memberOf MainPage
         */
        selDialogLabels: {
          type: Array,
          value: [],
          notify: true,
        },

        /**
         * True if label changes in dialog should apply to all selectedClips
         * @memberOf MainPage
         */
        isMultiLabelsEdit: {
          type: Boolean,
          value: false,
          notify: true,
        },

        /**
         * True if we are performing an operation on multiple clips
         * @memberOf MainPage
         */
        isBulkOp: {
          type: Boolean,
          value: false,
          notify: true,
        },
      },

      observers: [
        '_selDialogLabelsAddedOrRemoved(selDialogLabels.splices)',
      ],

      /**
       * Element is ready
       * @memberOf MainPage
       */
      ready: function() {
        self = this;
        this.set('canSend', app.Utils.canSend());
        this._loadClipItems(true).then(() => {
          // !Important
          this.$.clipList.deselectAll();
          this.$.clipList.selectFirst();

          // don't do in attached. need clips to be loaded before listening
          Chrome.Msg.listen(this._onChromeMessage.bind(this));

          // listen for copy and cut events on document
          document.addEventListener('cut', this._onCopy.bind(this), true);
          document.addEventListener('copy', this._onCopy.bind(this), true);

          return Promise.resolve();
        }).catch((err) => {
          Chrome.Log.error(err.message, 'MainPage.ready', _ERR_LOAD);
        });
      },

      /**
       * We have animated in and are now the current page
       * @memberOf MainPage
       */
      onCurrentPage: function() {
        this.set('isBulkOp', false);
        this.set('canSend', app.Utils.canSend());
        this.$.clipList.selectFirst(true);
        this.$.clipList.updateDates();
      },

      /**
       * We are not going to be current anymore
       * @memberOf MainPage
       */
      onLeavePage: function() {
        this.set('isBulkOp', false);
        this._closeUndoToast();
        this.$.clipList.deselectAll();
      },

      /**
       * Set {@link Label} name for filtering
       * @param {string} [labelName = '']
       * @memberOf MainPage
       */
      setLabelFilter: function(labelName = '') {
        if (this.labelFilter === labelName) {
          this.$.clipList.updateDates();
        } else {
          this.set('labelFilter', labelName);
        }
      },

      // noinspection JSUnusedLocalSymbols
      /**
       * Event: Fired when a message is sent from either an extension process&lt;br>
       * (by runtime.sendMessage) or a content script (by tabs.sendMessage).
       * @see https://developer.chrome.com/extensions/runtime#event-onMessage
       * @param {Chrome.Msg.Message} request - details for the
       * @param {Object} sender - MessageSender object
       * @param {function} response - function to call once after processing
       * @returns {boolean} true if asynchronous
       * @private
       * @memberOf MainPage
       */
      _onChromeMessage: function(request, sender, response) {
        let ret = false;
        if (request.message === app.ChromeMsg.CLIP_ITEM_CREATED.message) {
          ret = true; // async
          this.$.clipList.addClipItem(request.item);
        } else if (request.message === app.ChromeMsg.CLIP_ITEM_UPDATED.message) {
          const item = request.item;
          this.$.clipList.updateClipItem(item.text, item.mods);
        } else if (request.message === app.ChromeMsg.CLIP_ITEM_DELETED.message) {
          this.$.clipList.deleteClipItem(request.item);
        } else if (request.message === app.ChromeMsg.NO_REMOTE_DEVICES.message) {
          this.set('canSend', app.Utils.canSend());
        }
        return ret;
      },

      /**
       * Event: Select labels menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onSelectLabelsTapped: function() {
        Chrome.GA.event(Chrome.GA.EVENT.ICON, 'selectLabels');
        this._showLabelsDialog(true);
      },

      /**
       * Event: Select all menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onSelectAllTapped: function() {
        Chrome.GA.event(Chrome.GA.EVENT.ICON, 'selectAllClipItems');
        this.$.clipList.deselectAll();
        this.$.clipList.selectAll();
      },

      /**
       * Event: Deselect all menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onDeselectAllTapped: function() {
        Chrome.GA.event(Chrome.GA.EVENT.ICON, 'deselectAllClipItems');
        this.$.clipList.deselectAll();
      },

      /**
       * Event: Delete menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onDeleteSelectedTapped: function() {
        Chrome.GA.event(Chrome.GA.EVENT.ICON, 'deleteSelectedClipItems');

        // save items for undo
        const keys = [];
        this.splice('undoClips', 0, this.undoClips.length);
        const clipItems = this.$.clipList.getSelected();
        clipItems.forEach((clipItem) => {
          keys.push(clipItem._id);
          this.push('undoClips', clipItem);
        });

        if (keys.length) {
          // skip updates until bulk operation is complete
          this.set('isBulkOp', true);
          this.$.clipList.deselectAll();
          app.ClipItem.remove(keys).then(() => {
            this.set('isBulkOp', false);
            const len = this.undoClips.length;
            let toastText =
                (len === 1) ? 'Deleted 1 item.' : `Deleted ${len} items.`;
            this.set('undoText', toastText);
            this.$.undoToast.show();
            return Promise.resolve();
          }).catch((err) => {
            this.set('isBulkOp', false);
            Chrome.Log.error(err.message, 'MainPage._onDeleteSelectedRows',
                'Failed to delete clips.');
          });
        }
      },

      /**
       * Event: Send clipboard contents icon tapped
       * @private
       * @memberOf MainPage
       */
      _onSendTapped: function() {
        Chrome.GA.event(Chrome.GA.EVENT.ICON, 'sendClipboardContents');
        Chrome.Msg.send(app.ChromeMsg.COPIED_TO_CLIPBOARD).catch(() => {});
      },

      /**
       * Event: Pin menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onPinTapped: function() {
        this.set('isPinFavs', !this.isPinFavs);
        Chrome.GA.event(Chrome.GA.EVENT.ICON, `pinFavorites: ${this.isPinFavs}`);
      },

      /**
       * Event: Favorite filter menu icon tapped
       * @private
       * @memberOf MainPage
       */
      _onFavFilterTapped: function() {
        this.set('isFavFilter', !this.isFavFilter);
        Chrome.GA.event(Chrome.GA.EVENT.ICON,
            `filterByFavorites: ${this.isFavFilter}`);

        this._loadClipItems(true).catch((err) => {
          Chrome.Log.error(err.message, 'MainPage._onFavFilterTapped', _ERR_LOAD);
        });
      },

      /**
       * Event: Undo Toast close button tapped
       * @private
       * @memberOf MainPage
       */
      _onCloseToastTapped: function() {
        Chrome.GA.event(app.GA.EVENT.IMAGE_BUTTON, 'closeUndoToast');
        this._closeUndoToast();
      },

      /**
       * Event: Undo Toast button tapped&lt;br />
       * Restore the deleted Items
       * @private
       * @memberOf MainPage
       */
      _onUndoDeleteTapped: function() {
        Chrome.GA.event(Chrome.GA.EVENT.BUTTON, 'UNDO');
        this.set('isBulkOp', true);
        app.ClipItem.bulkPut(this.undoClips).then(() => {
          this.set('isBulkOp', false);
          // reset selections
          const newClipItems = [];
          this.undoClips.forEach((clipItem) => {
            // need to use new item reference - hashing issue in iron-list?
            const newClipItem = this.$.clipList.getClip(clipItem.text);
            if (newClipItem) {
              newClipItems.push(newClipItem);
            }
          });
          this.$.clipList.selectClipItems(newClipItems);
          this._setCurrentClip();
          this._closeUndoToast();
          return Promise.resolve();
        }).catch((err) => {
          Chrome.Log.error(err.message, 'MainPage._onUndoDeleteTapped',
              'Failed to undo delete.');
          this.set('isBulkOp', false);
          this._closeUndoToast();
        });
      },

      /**
       * Event: The selected {@link ClipItem} changed
       * @private
       * @memberOf MainPage
       */
      _onSelectedClipChanged: function() {
        this._setCurrentClip();
        this.set('hasSelections', !!this.$.clipList.getSelectedCount());
      },

      /**
       * Event: Label of {@link ClipItem} row tapped
       * @param {Event} event
       * @private
       * @memberOf MainPage
       */
      _onRowLabelTapped: function(event) {
        this._showLabelsDialog(false);
      },

      /**
       * Event: Labels of {@link ClipViewer} tapped
       * @param {Event} event
       * @private
       * @memberOf MainPage
       */
      _onViewerLabelsTapped: function(event) {
        this._showLabelsDialog(false);
      },

      /**
       * Event: {@link ClipViewer} wants to change the text
       * @param {Event} event
       * @param {Event} event.detail - new text
       * @private
       * @memberOf MainPage
       */
      _onViewerTextChanged: function(event) {
        const newText = event.detail.text;
        if (!Chrome.Utils.isWhiteSpace(newText)) {
          let clipItem = this.$.clipList.getClip(newText);
          if (clipItem) {
            // text changed to an existing clip, update it instead
            clipItem.update({
              date: Date.now(),
              remote: false,
            }).then(() => {
              // delete the one we were editing
              return this.currentClip.delete();
            }).then(() => {
              this.$.clipList.deselectAll();
              this.$.clipList.selectByText(newText);
              this.$.clipList.scrollToText(newText);
              // send message to copy to clipboard
              const msg =
                  Chrome.JSONUtils.shallowCopy(app.ChromeMsg.COPY_TO_CLIPBOARD);
              msg.item = clipItem;
              // eslint-disable-next-line promise/no-nesting
              Chrome.Msg.send(msg).catch(() => {});
              return Promise.resolve();
            }).catch((err) => {
              this._showMessageToast('Failed to update clip.', err);
            });
          } else {
            // update current clip
            this.currentClip.update({
              date: Date.now(),
              text: newText,
              remote: false,
            }).then(() => {
              this.$.clipList.scrollToText(newText);
              // send message to copy to clipboard
              const msg =
                  Chrome.JSONUtils.shallowCopy(app.ChromeMsg.COPY_TO_CLIPBOARD);
              msg.item = this.currentClip;
              // eslint-disable-next-line promise/no-nesting
              Chrome.Msg.send(msg).catch(() => {});
              return Promise.resolve();
            }).catch((err) => {
              this._showMessageToast('Failed to update clip.', err);
            });
          }
        } else {
          // delete it
          this.currentClip.delete().then(() => {
            this.$.clipList.selectFirst(true);
            return Promise.resolve();
          }).catch((err) => {
            this._showMessageToast('Failed to delete clip.', err);
          });
        }
      },

      /**
       * Event: {@link ClipViewer} wants to add a new {@link ClipItem}
       * @param {Event} event
       * @param {Event} event.detail - text for clip
       * @private
       * @memberOf MainPage
       */
      _onViewerClipAdd: function(event) {
        const text = event.detail.text;
        const date = Date.now();
        const device = app.Device.myName();
        app.ClipItem.add(text, date, false, false, device, true).then((clip) => {
          // send message to copy to clipboard
          const msg =
              Chrome.JSONUtils.shallowCopy(app.ChromeMsg.COPY_TO_CLIPBOARD);
          msg.item = clip;
          // eslint-disable-next-line promise/no-nesting
          Chrome.Msg.send(msg).catch(() => {});
          this.$.clipList.deselectAll();
          this.$.clipList.selectByText(text);
          this.$.clipList.scrollToText(text);
          return Promise.resolve();
        }).catch((err) => {
          this._showMessageToast('Failed to add clip.', err);
        });
      },

      /**
       * Event: Text was copied to clipboard
       * @private
       * @memberOf MainPage
       */
      _onCopy: function() {
        if (!this.isEditMode) {
          // skip when editing the current clip
          Chrome.Msg.send(app.ChromeMsg.COPIED_TO_CLIPBOARD).catch(() => {});
        }
      },

      /**
       * Event: Initialize pinFavs if it is not in localStorage
       * @private
       * @memberOf MainPage
       */
      _initPinFavs: function() {
        this.set('isPinFavs', 'false');
      },

      /**
       * Observer: The label filter changed
       * @param {string} newValue
       * @param {string|undefined} oldValue
       * @private
       * @memberOf MainPage
       */
      _labelFilterChanged: function(newValue, oldValue) {
        if (typeof(oldValue) !== 'undefined') {
          this.$.clipList.deselectAll();
          this._loadClipItems().catch((err) => {
            Chrome.Log.error(err.message, 'MainPage.setLabelFilter', _ERR_LOAD);
          });
        }
      },

      /**
       * Observer: selDialogLabels Array mutations
       * @param {{}} changeRecord
       * @private
       * @memberOf MainPage
       */
      _selDialogLabelsAddedOrRemoved: function(changeRecord) {
        if (changeRecord) {
          this.set('isBulkOp', true);
          const promises = [];
          if (this.isMultiLabelsEdit) {
            // track each added and removed label change and
            // apply to each selected clip
            const addedNames = [];
            const removedNames = [];
            const splices = changeRecord.indexSplices;
            splices.forEach((splice) => {
              for (let i = 0; i &lt; splice.addedCount; i++) {
                let index = splice.index + i;
                addedNames.push(splice.object[index]);
              }
              splice.removed.forEach((name) => {
                removedNames.push(name);
              });
            });
            const clipItems = this.$.clipList.getSelected();
            clipItems.forEach((clipItem) => {
              const names = clipItem.getLabelNames();

              addedNames.forEach((addedName) => {
                if (!clipItem.hasLabel(addedName)) {
                  names.push(addedName);
                }
              });

              removedNames.forEach((removedName) => {
                if (clipItem.hasLabel(removedName)) {
                  const idx = names.indexOf(removedName);
                  names.splice(idx, 1);
                }
              });

              promises.push(clipItem.setLabels(names));
            });
          } else {
            // apply to current clip
            const clipItem = this.currentClip;
            promises.push(clipItem.setLabels(this.selDialogLabels));
          }

          Promise.all(promises).then(() => {
            this.set('isBulkOp', false);
            if (this.labelFilter &amp;&amp;
                !this.selDialogLabels.includes(this.labelFilter)) {
              // deleted current label from item(s) 
              this.$.labelsDialog.close();
              return this._loadClipItems();
            } else {
              this._setCurrentClip();
              return Promise.resolve();
            }
          }).catch((err) => {
            this.set('isBulkOp', false);
            Chrome.Log.error(err.errorMessage,
                'MainPage._onSelectedLabelsChanged', 'Failed to set label.');
          });
        }
      },

      /**
       * Computed Binding
       * @param {ClipItem} clipItem
       * @param {string} labelName
       * @returns {string} Page title
       * @private
       * @memberOf MainPage
       */
      _computeTitle: function(clipItem, labelName) {
        let title = 'Clips';
        if (!Chrome.Utils.isWhiteSpace(labelName)) {
          title = `${labelName}`;
        }
        if (clipItem) {
          if (clipItem.remote) {
            title += `: Remote clip - ${clipItem.device}`;
          } else {
            title += ': Local clip';
          }
        }
        return title;
      },

      /**
       * Computed Binding: Title of Labels Dialog
       * @param {boolean} multi - true if dialog applies to all selectedClips
       * @returns {string} Dialog title
       * @private
       * @memberOf MainPage
       */
      _computeLabelsDialogTitle: function(multi) {
        if (multi &amp;&amp; (this.$.clipList.getSelectedCount() > 1)) {
          return 'Change labels for selected clips';
        } else {
          return 'Set labels for the current clip';
        }
      },

      /**
       * Computed Binding
       * @param {boolean} isTrue - true if we should pin favs to top
       * @returns {string} icon style
       * @private
       * @memberOf MainPage
       */
      _computePinIcon: function(isTrue) {
        return isTrue ? 'myicons:pin' : 'myicons:pin-off';
      },

      /**
       * Computed Binding
       * @param {boolean} isTrue - true if pinning favorites
       * @returns {string} tooltip text of what toggling would be
       * @private
       * @memberOf MainPage
       */
      _computePinToolTip: function(isTrue) {
        return isTrue ? 'Unpin favorites' : 'Pin favorites to top';
      },

      /**
       * Computed Binding
       * @param {boolean} isTrue - true if fav
       * @returns {string} icon style
       * @private
       * @memberOf MainPage
       */
      _computeFavIcon: function(isTrue) {
        return isTrue ? 'myicons:favorite' : 'myicons:favorite-border';
      },

      /**
       * Computed Binding
       * @param {boolean} isFilter - true if filtering by fav
       * @returns {string} tooltip text of what toggling would be
       * @private
       * @memberOf MainPage
       */
      _computeFavToolTip: function(isFilter) {
        return isFilter ? 'Show all' : 'Show favorites only';
      },

      /**
       * Computed Binding
       * @param {boolean} isTrue - true if fav
       * @returns {string} fav filter menu icon color
       * @private
       * @memberOf MainPage
       */
      _computeFavMenuColor: function(isTrue) {
        return isTrue ? 'rgba(255, 0, 0, .8)' : 'var(--menu-icon-color)';
      },

      /**
       * Load the {@link ClipItem} objects
       * @param {boolean} [isSelectFirst=true] - if true select first item
       * @returns {Promise&lt;void>}
       * @private
       * @memberOf MainPage
       */
      _loadClipItems: function(isSelectFirst = true) {
        this._closeUndoToast();
        return this.$.clipList.loadClipItems(isSelectFirst);
      },

      /**
       * Set clip viewer contents based on last selected
       * @private
       * @memberOf MainPage
       */
      _setCurrentClip: function() {
        let currentItem = this.$.clipList.getLastSelected();

        // override dirty checking
        this.set('currentClip', null);
        if (currentItem) {
          this.set('currentClip', currentItem);
        }
      },

      /**
       * Show Labels select dialog
       * @param {boolean} multi - if true apply changes to all selectItems
       * @private
       * @memberOf MainPage
       */
      _showLabelsDialog: function(multi) {
        this.set('isMultiLabelsEdit', multi);
        const list = this.$.clipList;
        if (multi &amp;&amp; (list.getSelectedCount() > 1)) {
          // for multi mode, apply to all selectedClips
          app.Label.loadAll().then((labels) => {
            // get all label names that all selected clips share
            const clipItems = list.getSelected();
            const names = [];
            labels = labels || [];
            labels.forEach((label) => {
              let hasLabel = true;
              for (let i = 0; i &lt; clipItems.length; i++) {
                const clipItem = clipItems[i];
                if (!clipItem.hasLabel(label.name)) {
                  hasLabel = false;
                  break;
                }
              }
              if (hasLabel) {
                names.push(label.name);
              }
            });
            return Promise.resolve(names);
          }).then((labelNames) => {
            this.set('selDialogLabels', labelNames);
            this.$.labelsDialog.open();
            return Promise.resolve();
          }).catch((err) => {
            Chrome.Log.error(err.message, 'MainPage._showLabelsDialog',
                'Failed to load labels');
          });
        } else {
          if (this.currentClip) {
            const names = this.currentClip.getLabelNames();
            this.set('selDialogLabels', names);
            this.$.labelsDialog.open();
          }
        }
      },

      /**
       * Show an auto hiding message toast
       * @param {string} text
       * @param {?Error} [err=null]
       * @private
       * @memberOf MainPage
       */
      _showMessageToast: function(text, err = null) {
        this.$.messageToast.fitInto = this.$.clipViewer;
        this.$.messageToast.text = text;
        this.$.messageToast.show();
        if (err) {
          Chrome.Log.error(err.message, 'MainPage._showMessageToast', text);
        }
      },

      /**
       * Close the Undo Toast
       * @private
       * @memberOf MainPage
       */
      _closeUndoToast: function() {
        if (this.undoClips &amp;&amp; this.undoClips.length) {
          this.splice('undoClips', 0, this.undoClips.length);
        }
        this.$.undoToast.close();
      },
    });

    /**
     * Document and resources loaded
     * @private
     * @memberOf MainPage
     */
    function _onLoad() {
      const db = app.DB.get();
      if (!db) {
        Chrome.Log.error('Failed to get database reference', 'MainPage._onLoad',
            'Database not found');
        return;
      }

      db.clipItems.hook('creating', function(primKey, obj) {
        // eslint-disable-next-line no-invalid-this
        this.onsuccess = function() {
          self.$.clipList.addClipItem(obj.text);
        };
      });

      db.clipItems.hook('updating', function(mods, primKey, obj) {
        // eslint-disable-next-line no-invalid-this
        this.onsuccess = function() {
          self.$.clipList.updateClipItem(obj.text, mods);
        };
      });

      db.clipItems.hook('deleting', function(primKey, obj) {
        // eslint-disable-next-line no-invalid-this
        this.onsuccess = function() {
          self.$.clipList.deleteClipItem(obj.text);
        };
      });
    }

    // listen for document and resources loaded
    window.addEventListener('load', _onLoad);
  })();</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


	<span class="copyright">
	DocStrap Copyright Â© 2012-2015 The contributors to the JSDoc3 and DocStrap projects.
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a>
	
		on December 20th 2017, 2:09:13 am
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
